\section{Implementation and Object-Oriented Principles}
\label{sec:implementation_oop}

This section delves into the implementation details of the system, with a specific focus on how the four fundamental principles of Object-Oriented Programming (OOP) \cite{Booch2007} were realized using the features of the C++ programming language \cite{Stroustrup2013}. The use of these principles was crucial for developing a system that is not only functional but also robust, modular, and maintainable.

\subsection{Encapsulation}
Encapsulation is the practice of bundling data and the methods that operate on that data into a single unit, while restricting direct access. This is achieved in C++ through access specifiers (`public`, `private`, `protected`).

In this project, all domain models enforce encapsulation. For example, the \texttt{User} class declares its attributes \texttt{userID} and \texttt{password} as \texttt{private}. Access from outside the class is only permitted through its public interface, protecting the object's internal state.

\begin{verbatim}
// -- Demonstrating Encapsulation in C++ --
class User {
private:
    // Data members are hidden from outside access
    std::string userID;
    std::string password;

public:
    // Public methods provide a controlled interface
    std::string getUserID() const;
    void setPassword(const std::string& newPassword);
};
\end{verbatim}

\subsection{Inheritance}
Inheritance allows a new class (subclass) to be based on an existing class (base class), promoting code reusability. C++ supports this directly through class derivation.

The system utilizes inheritance to model user types. The \texttt{Member} and \texttt{Librarian} classes both inherit publicly from the base \texttt{User} class. They acquire common attributes and functionalities while also implementing their own specialized methods.

\begin{verbatim}
// -- Demonstrating Inheritance in C++ --

// Base class
class User { /* ... */ };

// Derived class Member "is-a" User
class Member : public User {
private:
    // Member-specific attributes
    std::vector<Loan*> borrowedBooks;
public:
    // Member-specific behavior
    void borrowBook(const std::string& isbn);
};
\end{verbatim}

\subsection{Polymorphism}
Polymorphism allows objects of different classes to be treated as objects of a common superclass. In C++, this is primarily achieved at runtime through \texttt{virtual} functions.

A clear example is the Decorator pattern for books. The base \texttt{Book} class declares a \texttt{virtual} method \texttt{getFullDescription()}. Decorator classes override this method. When \texttt{getFullDescription()} is called on a \texttt{Book*} pointer, C++'s dynamic dispatch mechanism ensures the correct overridden version is invoked at runtime.

\begin{verbatim}
// -- Demonstrating Polymorphism in C++ --

// Base class defines the virtual interface
class Book {
public:
    virtual std::string getFullDescription() const {
        return "Title: " + this->title;
    }
};

// Decorator class overrides the virtual function
class SpecialTagDecorator : public Book {
private:
    Book* bookComponent;
    std::string tag;
public:
    std::string getFullDescription() const override {
        // Dynamically calls the wrapped object's method
        return bookComponent->getFullDescription() + " [Tag: " + tag + "]";
    }
};
\end{verbatim}

\subsection{Abstraction}
Abstraction involves hiding complex implementation details and exposing only essential functionalities. In C++, this is often achieved using abstract classes (classes with one or more pure virtual functions).

This principle is used in the Strategy pattern. An abstract class, \texttt{ISearchStrategy}, is defined with a pure virtual function \texttt{search() = 0}. This creates an interface, or a contract, that all concrete search strategy classes must implement, decoupling the client from the specific search algorithms.

\begin{verbatim}
// -- Demonstrating Abstraction in C++ --

// Abstract base class (Interface)
class ISearchStrategy {
public:
    virtual ~ISearchStrategy() = default;
    
    // Pure virtual function defines a contract
    virtual std::vector<Book*> search(
        const std::vector<Book*>& books,
        const std::string& query) = 0;
};

// Concrete implementation must provide the search method
class TitleSearchStrategy : public ISearchStrategy {
public:
    std::vector<Book*> search(
        const std::vector<Book*>& books,
        const std::string& query) override {
        // ... specific implementation for searching by title
    }
};
\end{verbatim}